# 🛠️ ДЕТАЛЬНИЙ ПЛАН ВИПРАВЛЕНЬ

## 📅 ТИЖДЕНЬ 1: КРИТИЧНІ ВИПРАВЛЕННЯ

### День 1: Логування та обробка помилок

#### Файл 1: `app_config.py` (НОВИЙ)
```python
"""
Конфігурація додатку з proper error handling
"""
import os
from dotenv import load_dotenv

load_dotenv()

class Config:
    # Security
    SECRET_KEY = os.getenv('SECRET_KEY')
    if not SECRET_KEY:
        raise ValueError("SECRET_KEY must be set in .env file")
    
    # Database
    SQLALCHEMY_DATABASE_URI = os.getenv(
        'DATABASE_URL',
        'postgresql://localhost/real_estate_agents'
    )
    SQLALCHEMY_TRACK_MODIFICATIONS = False
    SQLALCHEMY_ENGINE_OPTIONS = {
        'pool_size': 10,
        'pool_recycle': 3600,
        'pool_pre_ping': True,
        'max_overflow': 20,
        'connect_args': {
            'connect_timeout': 10,
            'options': '-c statement_timeout=30000'
        }
    }
    
    # HubSpot
    HUBSPOT_API_KEY = os.getenv('HUBSPOT_API_KEY')
    HUBSPOT_RATE_LIMIT_CALLS = 90
    HUBSPOT_RATE_LIMIT_PERIOD = 10
    
    # Logging
    LOG_LEVEL = os.getenv('LOG_LEVEL', 'INFO')
    LOG_FILE = 'logs/propart.log'
    LOG_MAX_BYTES = 10 * 1024 * 1024  # 10MB
    LOG_BACKUP_COUNT = 10
```

#### Файл 2: `logging_config.py` (НОВИЙ)
```python
"""
Налаштування логування
"""
import logging
from logging.handlers import RotatingFileHandler
import os

def setup_logging(app):
    """Налаштовує логування для додатку"""
    
    # Створюємо директорію для логів
    if not os.path.exists('logs'):
        os.mkdir('logs')
    
    # Налаштовуємо файловий handler
    file_handler = RotatingFileHandler(
        app.config['LOG_FILE'],
        maxBytes=app.config['LOG_MAX_BYTES'],
        backupCount=app.config['LOG_BACKUP_COUNT']
    )
    
    # Формат логів
    formatter = logging.Formatter(
        '[%(asctime)s] %(levelname)s in %(module)s: %(message)s'
    )
    file_handler.setFormatter(formatter)
    
    # Рівень логування
    log_level = getattr(logging, app.config['LOG_LEVEL'].upper())
    file_handler.setLevel(log_level)
    
    # Додаємо handler до app logger
    app.logger.addHandler(file_handler)
    app.logger.setLevel(log_level)
    
    # Логуємо старт додатку
    app.logger.info('ProPart Hub starting up')
    
    # Налаштовуємо SQLAlchemy logging
    if app.config.get('DEBUG'):
        logging.getLogger('sqlalchemy.engine').setLevel(logging.INFO)
    
    return app.logger
```

#### Файл 3: `error_handlers.py` (НОВИЙ)
```python
"""
Обробники помилок
"""
from flask import jsonify, render_template
from sqlalchemy.exc import SQLAlchemyError, OperationalError
from requests.exceptions import RequestException

def register_error_handlers(app, db):
    """Реєструє обробники помилок"""
    
    @app.errorhandler(404)
    def not_found_error(error):
        app.logger.warning(f'Page not found: {error}')
        return render_template('errors/404.html'), 404
    
    @app.errorhandler(500)
    def internal_error(error):
        app.logger.error(f'Internal server error: {error}')
        db.session.rollback()
        return render_template('errors/500.html'), 500
    
    @app.errorhandler(SQLAlchemyError)
    def handle_db_error(error):
        app.logger.error(f'Database error: {error}')
        db.session.rollback()
        return jsonify({
            'success': False,
            'error': 'Database error occurred'
        }), 500
    
    @app.errorhandler(OperationalError)
    def handle_db_connection_error(error):
        app.logger.error(f'Database connection error: {error}')
        db.session.rollback()
        return jsonify({
            'success': False,
            'error': 'Database connection lost'
        }), 503
    
    @app.errorhandler(RequestException)
    def handle_api_error(error):
        app.logger.error(f'API request error: {error}')
        return jsonify({
            'success': False,
            'error': 'External API error'
        }), 502
    
    @app.errorhandler(ValueError)
    def handle_validation_error(error):
        app.logger.warning(f'Validation error: {error}')
        return jsonify({
            'success': False,
            'error': str(error)
        }), 400
```

#### Зміни в `app.py`:
```python
# На початку файлу, після imports:
from app_config import Config
from logging_config import setup_logging
from error_handlers import register_error_handlers

# Замінити існуючу конфігурацію:
app = Flask(__name__)
app.config.from_object(Config)

# Додати логування:
logger = setup_logging(app)

# Додати error handlers:
register_error_handlers(app, db)

# Замінити всі print() на logger:
# print("HubSpot API успішно підключено!") →
logger.info("HubSpot API successfully connected")

# print(f"Помилка підключення HubSpot API: {e}") →
logger.error(f"HubSpot API connection error: {e}")
```

**Час виконання:** 4-6 годин  
**Тестування:** 1-2 години

---

### День 2: HubSpot Rate Limiting

#### Файл 4: `hubspot_rate_limiter.py` (НОВИЙ)
```python
"""
Rate limiter для HubSpot API
"""
import time
from functools import wraps
from requests.exceptions import HTTPError
from flask import current_app

class HubSpotRateLimiter:
    """Rate limiter з exponential backoff для HubSpot API"""
    
    def __init__(self, max_calls=90, period=10):
        self.max_calls = max_calls
        self.period = period
        self.calls = []
    
    def __call__(self, func):
        @wraps(func)
        def wrapper(*args, **kwargs):
            now = time.time()
            
            # Видаляємо старі виклики
            self.calls = [c for c in self.calls if c > now - self.period]
            
            # Чекаємо, якщо досягли ліміту
            if len(self.calls) >= self.max_calls:
                sleep_time = self.period - (now - self.calls[0])
                current_app.logger.warning(
                    f'Rate limit reached, sleeping {sleep_time:.2f}s'
                )
                time.sleep(sleep_time)
            
            self.calls.append(time.time())
            
            # Retry logic з exponential backoff
            max_retries = 3
            for attempt in range(max_retries):
                try:
                    return func(*args, **kwargs)
                
                except HTTPError as e:
                    if e.response.status_code == 429:
                        # Rate limit exceeded
                        retry_after = int(e.response.headers.get('Retry-After', 60))
                        current_app.logger.warning(
                            f'429 error, retry after {retry_after}s (attempt {attempt + 1}/{max_retries})'
                        )
                        if attempt < max_retries - 1:
                            time.sleep(retry_after)
                        else:
                            raise
                    elif e.response.status_code in [500, 502, 503, 504]:
                        # Server errors - retry with exponential backoff
                        if attempt < max_retries - 1:
                            sleep_time = 2 ** attempt
                            current_app.logger.warning(
                                f'{e.response.status_code} error, retrying in {sleep_time}s'
                            )
                            time.sleep(sleep_time)
                        else:
                            raise
                    else:
                        # Other HTTP errors - don't retry
                        raise
                
                except Exception as e:
                    # Other exceptions
                    if attempt < max_retries - 1:
                        sleep_time = 2 ** attempt
                        current_app.logger.warning(
                            f'Error: {e}, retrying in {sleep_time}s'
                        )
                        time.sleep(sleep_time)
                    else:
                        raise
        
        return wrapper

# Глобальний rate limiter
rate_limiter = HubSpotRateLimiter(
    max_calls=90,  # HubSpot limit: 100/10s, залишаємо запас
    period=10
)
```

#### Зміни в `app.py`:
```python
from hubspot_rate_limiter import rate_limiter

# Додати декоратор до всіх HubSpot функцій:

@rate_limiter
def fetch_notes_from_hubspot(lead):
    # ... існуючий код

@rate_limiter
def fetch_activities_from_hubspot(lead):
    # ... існуючий код

@rate_limiter
def sync_lead_from_hubspot(lead):
    # ... існуючий код

@rate_limiter
def create_note_in_hubspot(lead, note_text, note_type="note"):
    # ... існуючий код
```

#### Зміни в `templates/dashboard.html`:
```javascript
// Змінити інтервал автосинхронізації з 30 секунд на 5 хвилин
setInterval(function() {
    console.log('Автоматична синхронізація з HubSpot...');
    // ...
}, 300000); // 5 хвилин (замість 30000)
```

**Час виконання:** 2-3 години  
**Тестування:** 1-2 години

---

### День 3: Безпека (CSRF, Bcrypt, Rate Limiting)

#### Файл 5: `security.py` (НОВИЙ)
```python
"""
Налаштування безпеки
"""
from flask_wtf.csrf import CSRFProtect
from flask_limiter import Limiter
from flask_limiter.util import get_remote_address
from flask_bcrypt import Bcrypt

def init_security(app):
    """Ініціалізує security extensions"""
    
    # CSRF Protection
    csrf = CSRFProtect(app)
    
    # Rate Limiting
    limiter = Limiter(
        app=app,
        key_func=get_remote_address,
        default_limits=["200 per day", "50 per hour"],
        storage_uri=app.config.get('RATELIMIT_STORAGE_URL', 'memory://')
    )
    
    # Password Hashing
    bcrypt = Bcrypt(app)
    
    return csrf, limiter, bcrypt
```

#### Оновлення моделі User в `app.py`:
```python
# Замінити методи set_password та check_password:

def set_password(self, password):
    """Хешує пароль використовуючи bcrypt"""
    from security import bcrypt
    self.password_hash = bcrypt.generate_password_hash(password).decode('utf-8')

def check_password(self, password):
    """Перевіряє пароль"""
    from security import bcrypt
    return bcrypt.check_password_hash(self.password_hash, password)
```

#### Додати rate limiting до критичних endpoints:
```python
from security import limiter

@app.route('/login', methods=['POST'])
@limiter.limit("5 per minute")
def login():
    # ... існуючий код

@app.route('/register', methods=['POST'])
@limiter.limit("3 per hour")
def register():
    # ... існуючий код

@app.route('/add_lead', methods=['POST'])
@login_required
@limiter.limit("20 per minute")
def add_lead():
    # ... існуючий код
```

#### Оновити `requirements.txt`:
```txt
Flask-WTF==1.2.1
Flask-Limiter==3.5.0
Flask-Bcrypt==1.0.1
redis==5.0.1
```

**Час виконання:** 3-4 години  
**Тестування:** 2-3 години

---

## 📅 ТИЖДЕНЬ 2: ВАЖЛИВІ ПОКРАЩЕННЯ

### День 1-2: Alembic Migrations

#### Встановлення:
```bash
pip install alembic
alembic init migrations
```

#### Файл 6: `alembic.ini` (оновити)
```ini
[alembic]
script_location = migrations
sqlalchemy.url = postgresql://localhost/real_estate_agents

[loggers]
keys = root,sqlalchemy,alembic

[logger_alembic]
level = INFO
handlers =
qualname = alembic
```

#### Файл 7: `migrations/env.py` (оновити)
```python
from app import app, db

config.set_main_option(
    'sqlalchemy.url',
    app.config['SQLALCHEMY_DATABASE_URI']
)

target_metadata = db.metadata
```

#### Створення міграцій:
```bash
# Створити першу міграцію
alembic revision --autogenerate -m "Initial migration"

# Застосувати міграцію
alembic upgrade head

# Створити міграцію для індексів
alembic revision -m "Add indexes"
```

**Час виконання:** 4-6 годин  
**Тестування:** 2 години

---

### День 3: Індекси БД

#### Файл 8: `migrations/versions/XXXX_add_indexes.py`
```python
"""Add database indexes

Revision ID: XXXX
"""
from alembic import op

def upgrade():
    # Lead indexes
    op.create_index('idx_lead_agent_id', 'lead', ['agent_id'])
    op.create_index('idx_lead_status', 'lead', ['status'])
    op.create_index('idx_lead_created_at', 'lead', ['created_at'])
    op.create_index('idx_lead_updated_at', 'lead', ['updated_at'])
    op.create_index('idx_lead_hubspot_contact_id', 'lead', ['hubspot_contact_id'])
    op.create_index('idx_lead_hubspot_deal_id', 'lead', ['hubspot_deal_id'])
    
    # User indexes
    op.create_index('idx_user_role', 'user', ['role'])
    op.create_index('idx_user_is_active', 'user', ['is_active'])
    op.create_index('idx_user_level', 'user', ['level'])
    
    # Note status indexes
    op.create_index('idx_note_status_lead_id', 'note_status', ['lead_id'])
    op.create_index('idx_note_status_created_at', 'note_status', ['created_at'])
    
    # Activity indexes
    op.create_index('idx_activity_lead_id', 'activity', ['lead_id'])
    op.create_index('idx_activity_type', 'activity', ['activity_type'])
    op.create_index('idx_activity_created_at', 'activity', ['created_at'])

def downgrade():
    # Drop indexes
    op.drop_index('idx_lead_agent_id')
    op.drop_index('idx_lead_status')
    # ... інші індекси
```

**Застосування:**
```bash
alembic upgrade head
```

**Час виконання:** 2 години  
**Тестування:** 1 година

---

### День 4-5: Пагінація та Валідація

#### Файл 9: `validators.py` (НОВИЙ)
```python
"""
Валідатори для даних
"""
from marshmallow import Schema, fields, validate, ValidationError, validates
import phonenumbers

class LeadSchema(Schema):
    deal_name = fields.Str(
        required=True,
        validate=validate.Length(min=2, max=100)
    )
    email = fields.Email(required=True)
    phone = fields.Str(required=True)
    budget = fields.Str(
        validate=validate.OneOf([
            'до 200к', '200к–500к', '500к–1млн', '1млн+'
        ])
    )
    status = fields.Str(
        validate=validate.OneOf([
            'new', 'contacted', 'qualified', 'closed'
        ])
    )
    notes = fields.Str(validate=validate.Length(max=500))
    
    @validates('phone')
    def validate_phone(self, value):
        try:
            parsed = phonenumbers.parse(value, None)
            if not phonenumbers.is_valid_number(parsed):
                raise ValidationError('Invalid phone number')
        except phonenumbers.NumberParseException:
            raise ValidationError('Invalid phone number format')

lead_schema = LeadSchema()
```

#### Оновити routes в `app.py`:
```python
from validators import lead_schema, ValidationError

@app.route('/add_lead', methods=['POST'])
@login_required
def add_lead():
    # Валідація даних
    try:
        data = lead_schema.load(request.form)
    except ValidationError as err:
        flash('Validation error: ' + str(err.messages))
        return redirect(url_for('add_lead'))
    
    # ... решта коду

@app.route('/dashboard')
@login_required
def dashboard():
    # Пагінація
    page = request.args.get('page', 1, type=int)
    per_page = 20
    
    if current_user.role == 'admin':
        pagination = Lead.query.options(
            joinedload(Lead.agent)
        ).order_by(Lead.created_at.desc()).paginate(
            page=page, per_page=per_page, error_out=False
        )
    else:
        pagination = Lead.query.filter_by(
            agent_id=current_user.id
        ).order_by(Lead.created_at.desc()).paginate(
            page=page, per_page=per_page, error_out=False
        )
    
    leads = pagination.items
    # ... решта коду
```

**Додати до `requirements.txt`:**
```txt
marshmallow==3.20.1
```

**Час виконання:** 4-6 годин  
**Тестування:** 2 години

---

## 📋 ЧЕКЛИСТ ВИКОНАННЯ

### Тиждень 1:
- [ ] День 1: Створити `app_config.py`
- [ ] День 1: Створити `logging_config.py`
- [ ] День 1: Створити `error_handlers.py`
- [ ] День 1: Оновити `app.py` (logging)
- [ ] День 1: Створити директорію `logs/`
- [ ] День 1: Тестувати логування
- [ ] День 2: Створити `hubspot_rate_limiter.py`
- [ ] День 2: Оновити всі HubSpot функції
- [ ] День 2: Оновити `dashboard.html` (інтервал)
- [ ] День 2: Тестувати rate limiting
- [ ] День 3: Створити `security.py`
- [ ] День 3: Оновити User model (bcrypt)
- [ ] День 3: Додати rate limiting до routes
- [ ] День 3: Оновити `requirements.txt`
- [ ] День 3: Тестувати безпеку

### Тиждень 2:
- [ ] День 1: Встановити Alembic
- [ ] День 1: Створити initial migration
- [ ] День 2: Застосувати міграцію
- [ ] День 3: Створити міграцію для індексів
- [ ] День 3: Застосувати індекси
- [ ] День 4: Створити `validators.py`
- [ ] День 4: Додати валідацію до routes
- [ ] День 5: Додати пагінацію
- [ ] День 5: Оновити templates для пагінації
- [ ] День 5: Фінальне тестування

---

## 🧪 ТЕСТУВАННЯ

### Після кожного дня:
```bash
# 1. Backup БД
pg_dump real_estate_agents > backup_$(date +%Y%m%d).sql

# 2. Тестувати основний функціонал
python -m pytest tests/

# 3. Перевірити логи
tail -f logs/propart.log

# 4. Перевірити HubSpot синхронізацію
python test_hubspot.py
```

---

## 📞 ПІДТРИМКА

Якщо виникнуть проблеми при виконанні плану:
1. Перевірте логи: `logs/propart.log`
2. Перевірте стан БД: `psql -d real_estate_agents`
3. Перевірте .env файл
4. Зверніться до технічного керівника

**Успішного виконання! 🚀**

